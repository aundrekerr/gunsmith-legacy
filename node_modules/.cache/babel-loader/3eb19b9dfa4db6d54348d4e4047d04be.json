{"ast":null,"code":"let manifest;\nexport function buildPerks(theManifest, weapon) {\n  // console.log('----- Building perks. -----');\n  // Set up inital variables.\n  manifest = theManifest;\n  const itemDef = manifest.DestinyInventoryItemDefinition[weapon.hash];\n  let perkList;\n  perkList = collectPerks(itemDef);\n  return perkList;\n}\n\nfunction collectPerks(itemDef) {\n  // The goods.\n  const socketEntries = itemDef.sockets.socketEntries; // Maximum of 4 perk slots. Not a good idea since if 5-perk weapon could come later on.\n\n  let perkList = [[], [], [], [], []]; // Used to jump from perk columns.\n\n  let slotCheck = 0; // Map through slots to find ones that are genuine perks.\n\n  socketEntries.map(socket => {\n    // Check if perk is intrinsic. Weapon frames and exotic perks).\n    // let intrinsicHash = socket.singleInitialItemHash;\n    let intrinsicHash = socket.socketTypeHash;\n    let isIntrinsic;\n\n    if (intrinsicHash !== 0) {\n      // isIntrinsic = manifest.DestinyInventoryItemDefinition[socket.singleInitialItemHash].itemCategoryHashes.includes(2237038328);\n      isIntrinsic = socket.socketTypeHash === 3956125808 ? true : false;\n    } else {\n      isIntrinsic = false;\n    } // some are just 0 and won't return anything\n\n\n    if (socket.socketTypeHash !== 0) {\n      // If this socket category is \"WEAPON PERKS\" or \"INTRINSIC\"\n      if (manifest.DestinySocketTypeDefinition[socket.socketTypeHash].socketCategoryHash === 4241085061 || manifest.DestinySocketTypeDefinition[socket.socketTypeHash].socketCategoryHash === 3956125808) {\n        // Not a tracker\n        if (socket.preventInitializationOnVendorPurchase === true || socket.singleInitialItemHash === 2285418970) {\n          return null;\n        } // console.log(isIntrinsic)\n        // If this is the WEAPON FRAME or INTRINSIC PERK\n\n\n        if (isIntrinsic) {\n          perkList[slotCheck].push({\n            // hash: socket.reusablePlugItems[0].plugItemHash,\n            hash: manifest.DestinyPlugSetDefinition[socket.reusablePlugSetHash].reusablePlugItems[0].plugItemHash,\n            isCurated: false,\n            curatedOnly: false,\n            isIntrinsic: isIntrinsic\n          }); // Increment to move to next perk slot.\n\n          slotCheck++;\n        } else {\n          // New Curated Check. \n          // Doesn't \n          if (socket.hasOwnProperty('randomizedPlugSetHash') && socket.hasOwnProperty('reusablePlugItems') && socket.plugSources === 2) {\n            for (let i = 0; i < socket.reusablePlugItems.length; i++) {\n              const plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n              const randomizedPlugSetHash = socket.randomizedPlugSetHash;\n              const randomPerkPool = manifest.DestinyPlugSetDefinition[randomizedPlugSetHash].reusablePlugItems; // If this plug doesn't exist in the random slot, add it.\n\n              let curatedOnly = randomPerkPool.filter(plug => plug.plugItemHash === plugItemHash).length > 0 ? false : true;\n\n              if (curatedOnly) {\n                // If this perk is curated, but not exclusive to the curated roll.\n                perkList[slotCheck].push({\n                  hash: plugItemHash,\n                  isCurated: socket.reusablePlugItems.some(p => p.plugItemHash === socket.reusablePlugItems[i].plugItemHash),\n                  curatedOnly: true,\n                  isIntrinsic: isIntrinsic\n                });\n              }\n            }\n          } // Work on the random/set perks of the weapon.\n          // SET PERKS\n\n\n          if (socket.reusablePlugSetHash) {\n            for (let i = 0; i < manifest.DestinyPlugSetDefinition[socket.reusablePlugSetHash].reusablePlugItems.length; i++) {\n              const plugItemHash = manifest.DestinyPlugSetDefinition[socket.reusablePlugSetHash].reusablePlugItems[i].plugItemHash;\n              let curatedOnlyCheck = true; // If it's undefined, it's a Kill Tracker \n\n              if (typeof perkList[slotCheck] !== 'undefined') {\n                // if it has random perks, check to see if the perk is also available without being curated.\n                if (socket.hasOwnProperty('randomizedPlugSetHash')) {\n                  const perkSet = manifest.DestinyPlugSetDefinition[socket.randomizedPlugSetHash];\n\n                  for (var j = 0; j < perkSet.reusablePlugItems.length; j++) {\n                    if (perkSet.reusablePlugItems[j].plugItemHash === plugItemHash) {\n                      curatedOnlyCheck = false;\n                      break;\n                    }\n                  } // Only push this perk if it's exclusive to the curated roll.\n\n\n                  if (curatedOnlyCheck) {\n                    perkList[slotCheck].push({\n                      hash: plugItemHash,\n                      isCurated: socket.hasOwnProperty('randomizedPlugSetHash') ? true : false,\n                      curatedOnly: curatedOnlyCheck,\n                      isIntrinsic: isIntrinsic\n                    });\n                  }\n                } else {\n                  // Just push the perk normally if there are no random rolls tied to it.\n                  perkList[slotCheck].push({\n                    hash: plugItemHash,\n                    isCurated: socket.hasOwnProperty('randomizedPlugSetHash') ? true : false,\n                    curatedOnly: socket.hasOwnProperty('randomizedPlugSetHash') ? curatedOnlyCheck : false,\n                    isIntrinsic: isIntrinsic\n                  });\n                }\n              }\n            }\n          } // RANDOM PERKS\n\n\n          if (socket.hasOwnProperty('randomizedPlugSetHash')) {\n            const perkSet = manifest.DestinyPlugSetDefinition[socket.randomizedPlugSetHash];\n\n            for (let i = 0; i < perkSet.reusablePlugItems.length; i++) {\n              const plugItemHash = perkSet.reusablePlugItems[i].plugItemHash; // If this perk is curated, but not exclusive to the curated roll.\n\n              perkList[slotCheck].push({\n                hash: plugItemHash,\n                isCurated: socket.reusablePlugItems.some(p => p.plugItemHash === perkSet.reusablePlugItems[i].plugItemHash),\n                curatedOnly: false,\n                isIntrinsic: isIntrinsic\n              });\n            }\n          } // Increment to move to next perk slot.\n\n\n          slotCheck++;\n        }\n      }\n    }\n\n    return true;\n  });\n  return perkList;\n} // function oldCollectPerks(\n// \titemDef\n// ) {\n// \tconst socketEntries = itemDef.sockets.socketEntries;\n// \tlet perkList = [ [], [], [], [], [] ];\n// \tlet slotCheck = 0;\n// \t// Map through slots to find ones that are genuine perks.\n// \tsocketEntries.map(socket => {\n// \t\t// Check if perk is intrinsic.\n// \t\tlet intrinsicHash = socket.singleInitialItemHash;\n// \t\tlet isIntrinsic;\n// \t\t// Check if the socket is the instrinsic perk (weapon frame/exotic perk).\n// \t\tif ( intrinsicHash !== 0) {\n// \t\t\tisIntrinsic = manifest.DestinyInventoryItemDefinition[socket.singleInitialItemHash].itemCategoryHashes.includes(2237038328);\n// \t\t} else {\n// \t\t\tisIntrinsic = false;\n// \t\t}\n// \t\t// Check plug sources to filter out MWs, mods, shaders, etc.\n// \t\tif (socket.plugSources === 1 || socket.plugSources === 2) {\n// \t\t\t// Curated & Year 1 weapons. Loop through perk columns.\n// \t\t\tfor (let i = 0; i < socket.reusablePlugItems.length; i++) {\n// \t\t\t\tconst plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n// \t\t\t\tconst plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes;\n// \t\t\t\t// Filter out Kill Trackers.\n// \t\t\t\tif (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n// \t\t\t\t\t// Check for perks that are curated/static but not exclusive. \n// \t\t\t\t\tif (!(socket.randomizedPlugItems).some(p => p.plugItemHash === socket.reusablePlugItems[i].plugItemHash)) {\n// \t\t\t\t\t\t// If it has reusables AND randoms, it's curated.\n// \t\t\t\t\t\tif (socket.reusablePlugItems.length > 0 && socket.randomizedPlugItems.length > 0) {\n// \t\t\t\t\t\t\tperkList[slotCheck].push({\t\n// \t\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n// \t\t\t\t\t\t\t\tisCurated: true,\n// \t\t\t\t\t\t\t\tcuratedOnly: true,\n// \t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n// \t\t\t\t\t\t\t});\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\tperkList[slotCheck].push({\n// \t\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n// \t\t\t\t\t\t\t\tisCurated: false,\n// \t\t\t\t\t\t\t\tcuratedOnly: false,\n// \t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n// \t\t\t\t\t\t\t});\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Year 2+. Loop through perk columns.\n// \t\t\tfor (let i = 0; i < socket.randomizedPlugItems.length; i++) {\n// \t\t\t\tconst plugItemHash = socket.randomizedPlugItems[i].plugItemHash;\n// \t\t\t\tconst plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes;\n// \t\t\t\t// Filter out Kill Trackers.\n// \t\t\t\tif (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n// \t\t\t\t\t// Same as before, reversed for random perks. \n// \t\t\t\t\tif ((socket.reusablePlugItems).some(p => p.plugItemHash === socket.randomizedPlugItems[i].plugItemHash)) {\n// \t\t\t\t\t\tperkList[slotCheck].push({\n// \t\t\t\t\t\t\thash: socket.randomizedPlugItems[i].plugItemHash,\n// \t\t\t\t\t\t\tisCurated: true,\n// \t\t\t\t\t\t\tcuratedOnly: false,\n// \t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n// \t\t\t\t\t\t});\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\tperkList[slotCheck].push({\n// \t\t\t\t\t\t\thash: socket.randomizedPlugItems[i].plugItemHash,\n// \t\t\t\t\t\t\tisCurated: false,\n// \t\t\t\t\t\t\tcuratedOnly: false,\n// \t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n// \t\t\t\t\t\t});\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n// \t\t\t// Increment to move to next perk slot.\n// \t\t\tslotCheck++;\n// \t\t}\n// \t\t// ???\n// \t\treturn true;\n// \t});\n// \treturn perkList;\n// }\n// Old way of determining perks that were both curated and within random \n// rolls. Outputs an array of the perks that had duplicates.\n// let duplicatePerks = [];\n// perkList.map(column => {\n// \tlet seen = new Set();\n// \treturn column.some(currentPerk => {\t\n// \t\tif (seen.size === seen.add(currentPerk.hash).size){\n// \t\t\tduplicatePerks.push(currentPerk);\n// \t\t\treturn true;\n// \t\t}\n// \t\treturn false;\n// \t});\n// });","map":{"version":3,"sources":["/Users/aundrekerr/Documents/GitHub/gunsmith/src/utils/perks.js"],"names":["manifest","buildPerks","theManifest","weapon","itemDef","DestinyInventoryItemDefinition","hash","perkList","collectPerks","socketEntries","sockets","slotCheck","map","socket","intrinsicHash","socketTypeHash","isIntrinsic","DestinySocketTypeDefinition","socketCategoryHash","preventInitializationOnVendorPurchase","singleInitialItemHash","push","DestinyPlugSetDefinition","reusablePlugSetHash","reusablePlugItems","plugItemHash","isCurated","curatedOnly","hasOwnProperty","plugSources","i","length","randomizedPlugSetHash","randomPerkPool","filter","plug","some","p","curatedOnlyCheck","perkSet","j"],"mappings":"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","sourcesContent":["let manifest;\n\nexport function buildPerks(\n\ttheManifest,\n\tweapon\n) {\n\t// console.log('----- Building perks. -----');\n\n\t// Set up inital variables.\n\tmanifest = theManifest;\n\tconst itemDef = manifest.DestinyInventoryItemDefinition[weapon.hash];\n\tlet perkList;\n\t\n\tperkList = collectPerks(itemDef)\n\n\treturn perkList;\n}\n\nfunction collectPerks (\n\titemDef\n) {\n\t// The goods.\n\tconst socketEntries = itemDef.sockets.socketEntries;\n\n\t// Maximum of 4 perk slots. Not a good idea since if 5-perk weapon could come later on.\n\tlet perkList = [ [], [], [], [], [] ];\n\n\t// Used to jump from perk columns.\n\tlet slotCheck = 0;\n\n\t// Map through slots to find ones that are genuine perks.\n\tsocketEntries.map(socket => {\n\t\n\t\t// Check if perk is intrinsic. Weapon frames and exotic perks).\n\t\t// let intrinsicHash = socket.singleInitialItemHash;\n\t\tlet intrinsicHash = socket.socketTypeHash;\n\t\t\n\t\tlet isIntrinsic;\n\n\t\tif ( intrinsicHash !== 0) {\n\t\t\t// isIntrinsic = manifest.DestinyInventoryItemDefinition[socket.singleInitialItemHash].itemCategoryHashes.includes(2237038328);\n\t\t\tisIntrinsic = socket.socketTypeHash === 3956125808 ? true : false\n\t\t} else {\n\t\t\tisIntrinsic = false;\n\t\t}\n\n\t\t// some are just 0 and won't return anything\n\t\tif (socket.socketTypeHash !== 0) {\n\n\t\t\t// If this socket category is \"WEAPON PERKS\" or \"INTRINSIC\"\n\t\t\tif (\n\t\t\t\tmanifest.DestinySocketTypeDefinition[socket.socketTypeHash].socketCategoryHash === 4241085061\n\t\t\t\t|| manifest.DestinySocketTypeDefinition[socket.socketTypeHash].socketCategoryHash === 3956125808\n\t\t\t) {\n\n\t\t\t\t// Not a tracker\n\t\t\t\tif (\n\t\t\t\t\tsocket.preventInitializationOnVendorPurchase === true\n\t\t\t\t\t|| socket.singleInitialItemHash === 2285418970\n\t\t\t\t) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\t// console.log(isIntrinsic)\n\n\t\t\t\t// If this is the WEAPON FRAME or INTRINSIC PERK\n\t\t\t\tif (isIntrinsic) {\n\n\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\t// hash: socket.reusablePlugItems[0].plugItemHash,\n\t\t\t\t\t\thash: manifest.DestinyPlugSetDefinition[socket.reusablePlugSetHash].reusablePlugItems[0].plugItemHash,\n\t\t\t\t\t\tisCurated: false,\n\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t});\n\n\t\t\t\t\t// Increment to move to next perk slot.\n\t\t\t\t\tslotCheck++;\n\t\t\t\t} else {\n\n\n\t\t\t\t\t// New Curated Check. \n\t\t\t\t\t// Doesn't \n\t\t\t\t\tif (\n\t\t\t\t\t\tsocket.hasOwnProperty('randomizedPlugSetHash') && \n\t\t\t\t\t\tsocket.hasOwnProperty('reusablePlugItems') && \n\t\t\t\t\t\tsocket.plugSources === 2\n\t\t\t\t\t) {\n\t\t\t\t\t\tfor (let i = 0; i < socket.reusablePlugItems.length; i++) {\n\t\t\t\t\t\t\tconst plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n\t\t\t\t\t\t\tconst randomizedPlugSetHash = socket.randomizedPlugSetHash;\n\t\t\t\t\t\t\tconst randomPerkPool = manifest.DestinyPlugSetDefinition[randomizedPlugSetHash].reusablePlugItems;\n\n\t\t\t\t\t\t\t// If this plug doesn't exist in the random slot, add it.\n\t\t\t\t\t\t\tlet curatedOnly =  randomPerkPool.filter(plug => plug.plugItemHash === plugItemHash).length > 0 ? false : true;\n\n\t\t\t\t\t\t\tif (curatedOnly) {\n\t\t\t\t\t\t\t\t// If this perk is curated, but not exclusive to the curated roll.\n\t\t\t\t\t\t\t\tperkList[slotCheck].push({\n\t\t\t\t\t\t\t\t\thash: plugItemHash,\n\t\t\t\t\t\t\t\t\tisCurated: (socket.reusablePlugItems).some(p => p.plugItemHash === socket.reusablePlugItems[i].plugItemHash),\n\t\t\t\t\t\t\t\t\tcuratedOnly: true,\n\t\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\t\n\n\n\t\t\t\t\t// Work on the random/set perks of the weapon.\n\t\t\t\t\t// SET PERKS\n\t\t\t\t\tif ( socket.reusablePlugSetHash ) {\n\t\t\t\t\t\tfor (let i = 0; i < manifest.DestinyPlugSetDefinition[socket.reusablePlugSetHash].reusablePlugItems.length; i++) {\n\t\t\t\t\t\t\tconst plugItemHash = manifest.DestinyPlugSetDefinition[socket.reusablePlugSetHash].reusablePlugItems[i].plugItemHash;\n\t\t\t\t\t\t\tlet curatedOnlyCheck = true;\n\n\t\t\t\t\t\t\t// If it's undefined, it's a Kill Tracker \n\t\t\t\t\t\t\tif ( typeof perkList[slotCheck] !== 'undefined' ) {\n\n\t\t\t\t\t\t\t\t// if it has random perks, check to see if the perk is also available without being curated.\n\t\t\t\t\t\t\t\tif (socket.hasOwnProperty('randomizedPlugSetHash')) {\n\t\t\t\t\t\t\t\t\tconst perkSet = manifest.DestinyPlugSetDefinition[socket.randomizedPlugSetHash];\n\t\t\t\t\t\t\t\t\tfor(var j = 0; j < perkSet.reusablePlugItems.length; j++) {\n\t\t\t\t\t\t\t\t\t\tif (perkSet.reusablePlugItems[j].plugItemHash === plugItemHash) {\n\t\t\t\t\t\t\t\t\t\t\tcuratedOnlyCheck = false;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Only push this perk if it's exclusive to the curated roll.\n\t\t\t\t\t\t\t\t\tif ( curatedOnlyCheck ) {\n\t\t\t\t\t\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\t\t\t\t\t\thash: plugItemHash,\n\t\t\t\t\t\t\t\t\t\t\tisCurated: socket.hasOwnProperty('randomizedPlugSetHash') ? true : false,\n\t\t\t\t\t\t\t\t\t\t\tcuratedOnly: curatedOnlyCheck,\n\t\t\t\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Just push the perk normally if there are no random rolls tied to it.\n\t\t\t\t\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\t\t\t\t\thash: plugItemHash,\n\t\t\t\t\t\t\t\t\t\tisCurated: socket.hasOwnProperty('randomizedPlugSetHash') ? true : false,\n\t\t\t\t\t\t\t\t\t\tcuratedOnly: socket.hasOwnProperty('randomizedPlugSetHash') ? curatedOnlyCheck : false,\n\t\t\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// RANDOM PERKS\n\t\t\t\t\tif (socket.hasOwnProperty('randomizedPlugSetHash')) {\n\t\t\t\t\t\tconst perkSet = manifest.DestinyPlugSetDefinition[socket.randomizedPlugSetHash];\n\n\t\t\t\t\t\tfor (let i = 0; i < perkSet.reusablePlugItems.length; i++) {\n\t\t\t\t\t\t\tconst plugItemHash = perkSet.reusablePlugItems[i].plugItemHash;\n\n\t\t\t\t\t\t\t// If this perk is curated, but not exclusive to the curated roll.\n\t\t\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\t\t\thash: plugItemHash,\n\t\t\t\t\t\t\t\tisCurated: (socket.reusablePlugItems).some(p => p.plugItemHash === perkSet.reusablePlugItems[i].plugItemHash),\n\t\t\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment to move to next perk slot.\n\t\t\t\t\tslotCheck++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t});\n\n\treturn perkList;\n}\n\n\n\n\n\n\n// function oldCollectPerks(\n// \titemDef\n// ) {\n// \tconst socketEntries = itemDef.sockets.socketEntries;\n// \tlet perkList = [ [], [], [], [], [] ];\n// \tlet slotCheck = 0;\n\n// \t// Map through slots to find ones that are genuine perks.\n// \tsocketEntries.map(socket => {\n// \t\t// Check if perk is intrinsic.\n// \t\tlet intrinsicHash = socket.singleInitialItemHash;\n// \t\tlet isIntrinsic;\n\n// \t\t// Check if the socket is the instrinsic perk (weapon frame/exotic perk).\n// \t\tif ( intrinsicHash !== 0) {\n// \t\t\tisIntrinsic = manifest.DestinyInventoryItemDefinition[socket.singleInitialItemHash].itemCategoryHashes.includes(2237038328);\n// \t\t} else {\n// \t\t\tisIntrinsic = false;\n// \t\t}\n\n// \t\t// Check plug sources to filter out MWs, mods, shaders, etc.\n// \t\tif (socket.plugSources === 1 || socket.plugSources === 2) {\n\n// \t\t\t// Curated & Year 1 weapons. Loop through perk columns.\n// \t\t\tfor (let i = 0; i < socket.reusablePlugItems.length; i++) {\n// \t\t\t\tconst plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n// \t\t\t\tconst plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes;\n\n// \t\t\t\t// Filter out Kill Trackers.\n// \t\t\t\tif (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n\n// \t\t\t\t\t// Check for perks that are curated/static but not exclusive. \n// \t\t\t\t\tif (!(socket.randomizedPlugItems).some(p => p.plugItemHash === socket.reusablePlugItems[i].plugItemHash)) {\n// \t\t\t\t\t\t// If it has reusables AND randoms, it's curated.\n// \t\t\t\t\t\tif (socket.reusablePlugItems.length > 0 && socket.randomizedPlugItems.length > 0) {\n// \t\t\t\t\t\t\tperkList[slotCheck].push({\t\n// \t\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n// \t\t\t\t\t\t\t\tisCurated: true,\n// \t\t\t\t\t\t\t\tcuratedOnly: true,\n// \t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n// \t\t\t\t\t\t\t});\n// \t\t\t\t\t\t} else {\n// \t\t\t\t\t\t\tperkList[slotCheck].push({\n// \t\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n// \t\t\t\t\t\t\t\tisCurated: false,\n// \t\t\t\t\t\t\t\tcuratedOnly: false,\n// \t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n// \t\t\t\t\t\t\t});\n// \t\t\t\t\t\t}\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n\n// \t\t\t// Year 2+. Loop through perk columns.\n// \t\t\tfor (let i = 0; i < socket.randomizedPlugItems.length; i++) {\n// \t\t\t\tconst plugItemHash = socket.randomizedPlugItems[i].plugItemHash;\n// \t\t\t\tconst plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes;\n\n// \t\t\t\t// Filter out Kill Trackers.\n// \t\t\t\tif (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n\n// \t\t\t\t\t// Same as before, reversed for random perks. \n// \t\t\t\t\tif ((socket.reusablePlugItems).some(p => p.plugItemHash === socket.randomizedPlugItems[i].plugItemHash)) {\n// \t\t\t\t\t\tperkList[slotCheck].push({\n// \t\t\t\t\t\t\thash: socket.randomizedPlugItems[i].plugItemHash,\n// \t\t\t\t\t\t\tisCurated: true,\n// \t\t\t\t\t\t\tcuratedOnly: false,\n// \t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n// \t\t\t\t\t\t});\n// \t\t\t\t\t} else {\n// \t\t\t\t\t\tperkList[slotCheck].push({\n// \t\t\t\t\t\t\thash: socket.randomizedPlugItems[i].plugItemHash,\n// \t\t\t\t\t\t\tisCurated: false,\n// \t\t\t\t\t\t\tcuratedOnly: false,\n// \t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n// \t\t\t\t\t\t});\n// \t\t\t\t\t}\n// \t\t\t\t}\n// \t\t\t}\n\t\t\t\n// \t\t\t// Increment to move to next perk slot.\n// \t\t\tslotCheck++;\n// \t\t}\n\n// \t\t// ???\n// \t\treturn true;\n// \t});\n\n// \treturn perkList;\n// }\n\n\n// Old way of determining perks that were both curated and within random \n// rolls. Outputs an array of the perks that had duplicates.\n\t// let duplicatePerks = [];\n\t// perkList.map(column => {\n\t// \tlet seen = new Set();\n\t// \treturn column.some(currentPerk => {\t\n\t// \t\tif (seen.size === seen.add(currentPerk.hash).size){\n\t// \t\t\tduplicatePerks.push(currentPerk);\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// \t\treturn false;\n\t// \t});\n\t// });"]},"metadata":{},"sourceType":"module"}