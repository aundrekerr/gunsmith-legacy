{"ast":null,"code":"import Perks from \"../components/Weapon/Perks\";\nlet manifest;\nexport function buildPerks(theManifest, weapon) {\n  console.log('----- Building perks. -----'); // Set up inital variables.\n\n  manifest = theManifest;\n  const itemDef = manifest.DestinyInventoryItemDefinition[weapon.hash];\n  console.log(itemDef.displayProperties.name); // Maximum of 4 perk slots. Not a good idea since if 5-perk weapon could come later on.\n\n  let perkList;\n  perkList = collectPerks(itemDef);\n  return perkList;\n}\n\nfunction collectPerks(itemDef) {\n  const socketEntries = itemDef.sockets.socketEntries;\n  let perkList = [[], [], [], [], []];\n  let slotCheck = 0; // Map through slots to find ones that are genuine perks.\n\n  socketEntries.map(socket => {\n    // Check if perk is intrinsic.\n    let intrinsicHash = socket.singleInitialItemHash;\n    let isIntrinsic; // Check if the socket is the instrinsic perk (weapon frame/exotic perk).\n\n    if (intrinsicHash !== 0) {\n      isIntrinsic = manifest.DestinyInventoryItemDefinition[socket.singleInitialItemHash].itemCategoryHashes.includes(2237038328);\n    } else {\n      isIntrinsic = false;\n    } // some are just 0 and won't return anything\n\n\n    if (socket.socketTypeHash !== 0) {\n      // If this socket category is \"WEAPON PERKS\"\n      if (manifest.DestinySocketTypeDefinition[socket.socketTypeHash].socketCategoryHash === 4241085061) {\n        // If this is the WEAPON FRAME or INTRINSIC PERK\n        if (isIntrinsic) {\n          perkList[slotCheck].push({\n            hash: socket.reusablePlugItems[0].plugItemHash,\n            isCurated: false,\n            curatedOnly: false,\n            isIntrinsic: isIntrinsic\n          }); // Increment to move to next perk slot.\n\n          slotCheck++;\n        } else {\n          // Work on the random/set perks of the weapon.\n          // SET PERKS\n          if (socket.reusablePlugItems.length > 0) {\n            for (let i = 0; i < socket.reusablePlugItems.length; i++) {\n              const plugItemHash = socket.reusablePlugItems[i].plugItemHash; // If it's undefined, it's a Kill Tracker \n\n              if (typeof perkList[slotCheck] !== 'undefined') {\n                if (socket.hasOwnProperty('randomizedPlugSetHash')) {\n                  const perkSet = manifest.DestinyPlugSetDefinition[socket.randomizedPlugSetHash];\n\n                  if (socket.reusablePlugItems.some(p => p.plugItemHash === perkSet.reusablePlugItems[i].plugItemHash)) {\n                    console.log(manifest.DestinyInventoryItemDefinition[perkSet.reusablePlugItems[i].plugItemHash].displayProperties.name);\n                  } else {\n                    perkList[slotCheck].push({\n                      hash: socket.reusablePlugItems[i].plugItemHash,\n                      isCurated: socket.hasOwnProperty('randomizedPlugSetHash') ? true : false,\n                      curatedOnly: false,\n                      isIntrinsic: isIntrinsic\n                    });\n                  }\n                }\n              }\n            }\n          } // RANDOM PERKS\n\n\n          if (socket.hasOwnProperty('randomizedPlugSetHash')) {\n            const perkSet = manifest.DestinyPlugSetDefinition[socket.randomizedPlugSetHash];\n\n            for (let i = 0; i < perkSet.reusablePlugItems.length; i++) {\n              const plugItemHash = perkSet.reusablePlugItems[i].plugItemHash; // If this perk is curated, but not exclusive to the curated roll.\n\n              if (socket.reusablePlugItems.some(p => p.plugItemHash === perkSet.reusablePlugItems[i].plugItemHash)) {\n                perkList[slotCheck].push({\n                  hash: plugItemHash,\n                  isCurated: true,\n                  curatedOnly: false,\n                  isIntrinsic: isIntrinsic\n                });\n              } else {\n                perkList[slotCheck].push({\n                  hash: plugItemHash,\n                  isCurated: false,\n                  curatedOnly: false,\n                  isIntrinsic: isIntrinsic\n                });\n              }\n            }\n          } // Increment to move to next perk slot.\n\n\n          slotCheck++;\n          console.log('-----');\n        }\n      }\n    } // Moving item to top of array.\t\n    // let data = [\"email\",\"role\",\"type\",\"name\"];\n    // data = data.filter(item => item !== \"role\");\n    // data.unshift(\"role\");\n\n  });\n  return perkList;\n}\n\nfunction oldCollectPerks(itemDef) {\n  const socketEntries = itemDef.sockets.socketEntries;\n  let perkList = [[], [], [], [], []];\n  let slotCheck = 0; // Map through slots to find ones that are genuine perks.\n\n  socketEntries.map(socket => {\n    // Check if perk is intrinsic.\n    let intrinsicHash = socket.singleInitialItemHash;\n    let isIntrinsic; // Check if the socket is the instrinsic perk (weapon frame/exotic perk).\n\n    if (intrinsicHash !== 0) {\n      isIntrinsic = manifest.DestinyInventoryItemDefinition[socket.singleInitialItemHash].itemCategoryHashes.includes(2237038328);\n    } else {\n      isIntrinsic = false;\n    } // Check plug sources to filter out MWs, mods, shaders, etc.\n\n\n    if (socket.plugSources === 1 || socket.plugSources === 2) {\n      // Curated & Year 1 weapons. Loop through perk columns.\n      for (let i = 0; i < socket.reusablePlugItems.length; i++) {\n        const plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n        const plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes; // Filter out Kill Trackers.\n\n        if (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n          // Check for perks that are curated/static but not exclusive. \n          if (!socket.randomizedPlugItems.some(p => p.plugItemHash === socket.reusablePlugItems[i].plugItemHash)) {\n            // If it has reusables AND randoms, it's curated.\n            if (socket.reusablePlugItems.length > 0 && socket.randomizedPlugItems.length > 0) {\n              perkList[slotCheck].push({\n                hash: socket.reusablePlugItems[i].plugItemHash,\n                isCurated: true,\n                curatedOnly: true,\n                isIntrinsic: isIntrinsic\n              });\n            } else {\n              perkList[slotCheck].push({\n                hash: socket.reusablePlugItems[i].plugItemHash,\n                isCurated: false,\n                curatedOnly: false,\n                isIntrinsic: isIntrinsic\n              });\n            }\n          }\n        }\n      } // Year 2+. Loop through perk columns.\n\n\n      for (let i = 0; i < socket.randomizedPlugItems.length; i++) {\n        const plugItemHash = socket.randomizedPlugItems[i].plugItemHash;\n        const plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes; // Filter out Kill Trackers.\n\n        if (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n          // Same as before, reversed for random perks. \n          if (socket.reusablePlugItems.some(p => p.plugItemHash === socket.randomizedPlugItems[i].plugItemHash)) {\n            perkList[slotCheck].push({\n              hash: socket.randomizedPlugItems[i].plugItemHash,\n              isCurated: true,\n              curatedOnly: false,\n              isIntrinsic: isIntrinsic\n            });\n          } else {\n            perkList[slotCheck].push({\n              hash: socket.randomizedPlugItems[i].plugItemHash,\n              isCurated: false,\n              curatedOnly: false,\n              isIntrinsic: isIntrinsic\n            });\n          }\n        }\n      } // Increment to move to next perk slot.\n\n\n      slotCheck++;\n    } // ???\n\n\n    return true;\n  });\n  return perkList;\n} // Old way of determining perks that were both curated and within random \n// rolls. Outputs an array of the perks that had duplicates.\n// let duplicatePerks = [];\n// perkList.map(column => {\n// \tlet seen = new Set();\n// \treturn column.some(currentPerk => {\t\n// \t\tif (seen.size === seen.add(currentPerk.hash).size){\n// \t\t\tduplicatePerks.push(currentPerk);\n// \t\t\treturn true;\n// \t\t}\n// \t\treturn false;\n// \t});\n// });","map":{"version":3,"sources":["/Users/aundrekerr/Projects/React2019/gunsmith3/src/utils/perks.js"],"names":["Perks","manifest","buildPerks","theManifest","weapon","console","log","itemDef","DestinyInventoryItemDefinition","hash","displayProperties","name","perkList","collectPerks","socketEntries","sockets","slotCheck","map","socket","intrinsicHash","singleInitialItemHash","isIntrinsic","itemCategoryHashes","includes","socketTypeHash","DestinySocketTypeDefinition","socketCategoryHash","push","reusablePlugItems","plugItemHash","isCurated","curatedOnly","length","i","hasOwnProperty","perkSet","DestinyPlugSetDefinition","randomizedPlugSetHash","some","p","oldCollectPerks","plugSources","plugItemsCategories","randomizedPlugItems"],"mappings":"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","sourcesContent":["import Perks from \"../components/Weapon/Perks\";\n\nlet manifest;\n\nexport function buildPerks(\n\ttheManifest,\n\tweapon\n) {\n\tconsole.log('----- Building perks. -----');\n\n\t// Set up inital variables.\n\tmanifest = theManifest;\n\tconst itemDef = manifest.DestinyInventoryItemDefinition[weapon.hash];\n\n\tconsole.log(itemDef.displayProperties.name)\n\t// Maximum of 4 perk slots. Not a good idea since if 5-perk weapon could come later on.\n\tlet perkList;\n\t\n\tperkList = collectPerks(itemDef)\n\n\treturn perkList;\n}\n\nfunction collectPerks (\n\titemDef\n) {\n\tconst socketEntries = itemDef.sockets.socketEntries;\n\tlet perkList = [ [], [], [], [], [] ];\n\tlet slotCheck = 0;\n\n\t// Map through slots to find ones that are genuine perks.\n\tsocketEntries.map(socket => {\n\t\t// Check if perk is intrinsic.\n\t\tlet intrinsicHash = socket.singleInitialItemHash;\n\t\tlet isIntrinsic;\n\n\t\t// Check if the socket is the instrinsic perk (weapon frame/exotic perk).\n\t\tif ( intrinsicHash !== 0) {\n\t\t\tisIntrinsic = manifest.DestinyInventoryItemDefinition[socket.singleInitialItemHash].itemCategoryHashes.includes(2237038328);\n\t\t} else {\n\t\t\tisIntrinsic = false;\n\t\t}\n\n\t\t\n\n\t\t// some are just 0 and won't return anything\n\t\tif (socket.socketTypeHash !== 0) {\n\n\t\t\t// If this socket category is \"WEAPON PERKS\"\n\t\t\tif (manifest.DestinySocketTypeDefinition[socket.socketTypeHash].socketCategoryHash === 4241085061) {\n\n\t\t\t\t// If this is the WEAPON FRAME or INTRINSIC PERK\n\t\t\t\tif (isIntrinsic) {\n\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\thash: socket.reusablePlugItems[0].plugItemHash,\n\t\t\t\t\t\tisCurated: false,\n\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t});\n\n\t\t\t\t\t// Increment to move to next perk slot.\n\t\t\t\t\tslotCheck++;\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t// Work on the random/set perks of the weapon.\n\t\t\t\t\t// SET PERKS\n\t\t\t\t\tif ( socket.reusablePlugItems.length > 0) {\n\t\t\t\t\t\tfor (let i = 0; i < socket.reusablePlugItems.length; i++) {\n\t\t\t\t\t\t\tconst plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n\n\t\t\t\t\t\t\t// If it's undefined, it's a Kill Tracker \n\t\t\t\t\t\t\tif ( typeof perkList[slotCheck] !== 'undefined' ) {\n\n\t\t\t\t\t\t\t\tif (socket.hasOwnProperty('randomizedPlugSetHash')) {\n\t\t\t\t\t\t\t\t\tconst perkSet = manifest.DestinyPlugSetDefinition[socket.randomizedPlugSetHash];\n\n\t\t\t\t\t\t\t\t\tif ( (socket.reusablePlugItems).some(p => p.plugItemHash === perkSet.reusablePlugItems[i].plugItemHash) ) {\n\t\t\t\t\t\t\t\t\t\tconsole.log(manifest.DestinyInventoryItemDefinition[perkSet.reusablePlugItems[i].plugItemHash].displayProperties.name)\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n\t\t\t\t\t\t\t\t\t\t\tisCurated: socket.hasOwnProperty('randomizedPlugSetHash') ? true : false,\n\t\t\t\t\t\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// RANDOM PERKS\n\t\t\t\t\tif (socket.hasOwnProperty('randomizedPlugSetHash')) {\n\t\t\t\t\t\tconst perkSet = manifest.DestinyPlugSetDefinition[socket.randomizedPlugSetHash];\n\n\t\t\t\t\t\tfor (let i = 0; i < perkSet.reusablePlugItems.length; i++) {\n\t\t\t\t\t\t\tconst plugItemHash = perkSet.reusablePlugItems[i].plugItemHash;\n\n\t\t\t\t\t\t\t// If this perk is curated, but not exclusive to the curated roll.\n\t\t\t\t\t\t\tif ( (socket.reusablePlugItems).some(p => p.plugItemHash === perkSet.reusablePlugItems[i].plugItemHash) ) {\n\t\t\t\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\t\t\t\thash: plugItemHash,\n\t\t\t\t\t\t\t\t\tisCurated: true,\n\t\t\t\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\t\t\t\thash: plugItemHash,\n\t\t\t\t\t\t\t\t\tisCurated: false,\n\t\t\t\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Increment to move to next perk slot.\n\t\t\t\t\tslotCheck++;\n\t\t\t\t\tconsole.log('-----')\n\t\t\t\t}\n\n\t\t\t\t\n\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t// Moving item to top of array.\t\n\t\t// let data = [\"email\",\"role\",\"type\",\"name\"];\n\t\t// data = data.filter(item => item !== \"role\");\n\t\t// data.unshift(\"role\");\n\t\t\n\t});\n\n\treturn perkList;\n}\n\n\n\n\n\n\nfunction oldCollectPerks(\n\titemDef\n) {\n\tconst socketEntries = itemDef.sockets.socketEntries;\n\tlet perkList = [ [], [], [], [], [] ];\n\tlet slotCheck = 0;\n\n\t// Map through slots to find ones that are genuine perks.\n\tsocketEntries.map(socket => {\n\t\t// Check if perk is intrinsic.\n\t\tlet intrinsicHash = socket.singleInitialItemHash;\n\t\tlet isIntrinsic;\n\n\t\t// Check if the socket is the instrinsic perk (weapon frame/exotic perk).\n\t\tif ( intrinsicHash !== 0) {\n\t\t\tisIntrinsic = manifest.DestinyInventoryItemDefinition[socket.singleInitialItemHash].itemCategoryHashes.includes(2237038328);\n\t\t} else {\n\t\t\tisIntrinsic = false;\n\t\t}\n\n\t\t// Check plug sources to filter out MWs, mods, shaders, etc.\n\t\tif (socket.plugSources === 1 || socket.plugSources === 2) {\n\n\t\t\t// Curated & Year 1 weapons. Loop through perk columns.\n\t\t\tfor (let i = 0; i < socket.reusablePlugItems.length; i++) {\n\t\t\t\tconst plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n\t\t\t\tconst plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes;\n\n\t\t\t\t// Filter out Kill Trackers.\n\t\t\t\tif (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n\n\t\t\t\t\t// Check for perks that are curated/static but not exclusive. \n\t\t\t\t\tif (!(socket.randomizedPlugItems).some(p => p.plugItemHash === socket.reusablePlugItems[i].plugItemHash)) {\n\t\t\t\t\t\t// If it has reusables AND randoms, it's curated.\n\t\t\t\t\t\tif (socket.reusablePlugItems.length > 0 && socket.randomizedPlugItems.length > 0) {\n\t\t\t\t\t\t\tperkList[slotCheck].push({\t\n\t\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n\t\t\t\t\t\t\t\tisCurated: true,\n\t\t\t\t\t\t\t\tcuratedOnly: true,\n\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tperkList[slotCheck].push({\n\t\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n\t\t\t\t\t\t\t\tisCurated: false,\n\t\t\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Year 2+. Loop through perk columns.\n\t\t\tfor (let i = 0; i < socket.randomizedPlugItems.length; i++) {\n\t\t\t\tconst plugItemHash = socket.randomizedPlugItems[i].plugItemHash;\n\t\t\t\tconst plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes;\n\n\t\t\t\t// Filter out Kill Trackers.\n\t\t\t\tif (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n\n\t\t\t\t\t// Same as before, reversed for random perks. \n\t\t\t\t\tif ((socket.reusablePlugItems).some(p => p.plugItemHash === socket.randomizedPlugItems[i].plugItemHash)) {\n\t\t\t\t\t\tperkList[slotCheck].push({\n\t\t\t\t\t\t\thash: socket.randomizedPlugItems[i].plugItemHash,\n\t\t\t\t\t\t\tisCurated: true,\n\t\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tperkList[slotCheck].push({\n\t\t\t\t\t\t\thash: socket.randomizedPlugItems[i].plugItemHash,\n\t\t\t\t\t\t\tisCurated: false,\n\t\t\t\t\t\t\tcuratedOnly: false,\n\t\t\t\t\t\t\tisIntrinsic: isIntrinsic\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Increment to move to next perk slot.\n\t\t\tslotCheck++;\n\t\t}\n\n\t\t// ???\n\t\treturn true;\n\t});\n\n\treturn perkList;\n}\n\n\n// Old way of determining perks that were both curated and within random \n// rolls. Outputs an array of the perks that had duplicates.\n\t// let duplicatePerks = [];\n\t// perkList.map(column => {\n\t// \tlet seen = new Set();\n\t// \treturn column.some(currentPerk => {\t\n\t// \t\tif (seen.size === seen.add(currentPerk.hash).size){\n\t// \t\t\tduplicatePerks.push(currentPerk);\n\t// \t\t\treturn true;\n\t// \t\t}\n\t// \t\treturn false;\n\t// \t});\n\t// });"]},"metadata":{},"sourceType":"module"}