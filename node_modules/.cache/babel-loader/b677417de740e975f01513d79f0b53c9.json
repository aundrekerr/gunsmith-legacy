{"ast":null,"code":"let manifest;\nexport const statWhiteList = [3614673599, // Blast Radius\n2523465841, // Velocity\n4043523819, // Impact\n1240592695, // Range\n1591432999, // Accuracy\n155624089, // Stability\n943549884, // Handling\n4188031367, // Reload Speed\n2837207746, // Swing Speed (sword)\n2762071195, // Efficiency (sword)\n209426660, // Defense (sword)\n1345609583, // Aim Assistance\n3555269338, // Zoom\n2715839340, // Recoil Direction\n4284893193, // Rounds Per Minute\n2961396640, // Charge Time\n447667954, // Draw Time\n3871231066, // Magazine\n1931675084, // Inventory Size\n925767036];\nconst statsNoBar = [4284893193, // Rounds Per Minute\n3871231066, // Magazine\n2961396640, // Charge Time\n447667954, // Draw Time\n1931675084, // Recovery\n2715839340 // Recoil Direction\n];\nexport const statsMs = [447667954, // Draw Time\n2961396640 // Charge Time\n];\nconst hiddenStatsWhitelist = [1345609583, // Aim Assistance\n3555269338, // Zoom\n2715839340 // Recoil Direction\n];\nexport function buildStats(theManifest, itemHash) {\n  console.log('----- Building stats. -----');\n  manifest = theManifest;\n  const itemDef = manifest.DestinyInventoryItemDefinition[itemHash];\n\n  if (!itemDef.stats || !itemDef.stats.statGroupHash) {\n    return null;\n  }\n\n  const statGroup = manifest.DestinyStatGroupDefinition[itemDef.stats.statGroupHash];\n\n  if (!statGroup) {\n    return null;\n  }\n\n  let investmentStats = buildInvestmentStats(itemDef, statGroup);\n  return investmentStats.sort((a, b) => {\n    return a.sort - b.sort;\n  });\n}\n\nfunction shouldShowStat(itemDef, statHash, statDisplays) {\n  if (statHash === 2961396640 && itemDef.itemCategoryHashes && itemDef.itemCategoryHashes.includes(3317538576)) {\n    return false;\n  }\n\n  return (// Must be on the whitelist\n    statWhiteList.includes(statHash) && ( // Must be on the list of interpolated stats, or included in the hardcoded hidden stats list\n    statDisplays.filter(s => statHash === s.statHash)[0] || hiddenStatsWhitelist.includes(statHash))\n  );\n}\n\nfunction buildInvestmentStats(itemDef, statGroup) {\n  const itemStats = itemDef.investmentStats;\n  const statDisplays = statGroup.scaledStats;\n  return itemStats.map(itemStat => {\n    const statHash = itemStat.statTypeHash;\n\n    if (!itemStat || !shouldShowStat(itemDef, statHash, statDisplays)) {\n      return undefined;\n    }\n\n    const def = manifest.DestinyStatDefinition[statHash];\n\n    if (!def) {\n      return undefined;\n    }\n\n    return buildStat(itemStat, statGroup, def, statDisplays);\n  });\n}\n\nfunction buildStat(itemStat, statGroup, statDef, statDisplays) {\n  const statHash = itemStat.statTypeHash;\n  let value = itemStat.value || 0;\n  let maximumValue = statGroup.maximumValue;\n  let bar = !statsNoBar.includes(statHash);\n  let smallerIsBetter = false;\n  const statDisplay = statDisplays.filter(s => statHash === s.statHash)[0];\n  let intd = false;\n\n  if (statDisplay) {\n    const firstInterp = statDisplay.displayInterpolation[0];\n    const lastInterp = statDisplay.displayInterpolation[statDisplay.displayInterpolation.length - 1];\n    smallerIsBetter = firstInterp.weight > lastInterp.weight;\n    maximumValue = Math.max(statDisplay.maximumValue, firstInterp.weight, lastInterp.weight);\n    bar = !statDisplay.displayAsNumeric;\n    value = interpolateStatValue(value, statDisplay);\n    intd = true;\n  }\n\n  value = Math.max(0, value);\n  return {\n    investmentValue: itemStat.value || 0,\n    value,\n    intd,\n    statHash,\n    displayProperties: statDef.displayProperties,\n    sort: statWhiteList.indexOf(statHash),\n    maximumValue,\n    bar,\n    smallerIsBetter\n  };\n}\n\nfunction interpolateStatValue(value, statDisplay) {\n  const interp = statDisplay.displayInterpolation;\n  value = Math.max(0, Math.min(value, statDisplay.maximumValue));\n  let endIndex = interp.findIndex(p => p.value > value);\n\n  if (endIndex < 0) {\n    endIndex = interp.length - 1;\n  }\n\n  const startIndex = Math.max(0, endIndex - 1);\n  const start = interp[startIndex];\n  const end = interp[endIndex];\n  const range = end.value - start.value;\n\n  if (range === 0) {\n    return start.weight;\n  }\n\n  const t = (value - start.value) / (end.value - start.value);\n  return Math.round(start.weight + t * (end.weight - start.weight));\n}\n\nexport function enhanceStatsWithPlugs(baseStats, hash, perks, mod, masterwork) {\n  // console.log(baseStats, perks, mod, masterwork);\n  const itemDef = manifest.DestinyInventoryItemDefinition[hash];\n  const statGroup = manifest.DestinyStatGroupDefinition[itemDef.stats.statGroupHash];\n  Object.keys(perks).map(perk => {\n    const perkDef = manifest.DestinyInventoryItemDefinition[perks[perk].hash];\n    const statDisplays = statGroup.scaledStats;\n\n    for (const baseStat of baseStats) {\n      if (baseStat && perkDef) {\n        for (const perkStat of perkDef.investmentStats) {\n          const statHash = perkStat.statTypeHash;\n          const itemStat = baseStat;\n          const statDisplay = statDisplays.filter(s => statHash === s.statHash)[0];\n          const value = perkStat.value || 0;\n\n          if (itemStat) {\n            itemStat.investmentValue += value;\n            console.log(itemStat);\n            console.log(interpolateStatValue(itemStat.investmentValue, statDisplay));\n          } else if (shouldShowStat(itemDef, statHash, statDisplays)) {// const stat = perkDef.investmentStats.find( (s) => s.statTypeHash === statHash );\n            // console.log(stat);\n            // if (stat && stat.value) {\n            // const statDef = defs.Stat.get(statHash);\n            // const builtStat = buildStat(stat, statGroup, statDef, statDisplays);\n            // statsByHash[statHash] = builtStat;\n            // stats.push(statsByHash[statHash]);\n            // }\n          }\n        }\n      }\n    }\n  }); // const statsByHash = _.keyBy(stats, (s) => s.statHash);\n  // const modifiedStats = new Set<number>();\n  // Add the chosen plugs' investment stats to the item's base investment stats\n  // for (const socket of sockets) {\n  // \tif (socket.plug) {\n  // \t\tfor (const perkStat of socket.plug.plugItem.investmentStats) {\n  // \t\t\tconst statHash = perkStat.statTypeHash;\n  // \t\t\tconst itemStat = statsByHash[statHash];\n  // \t\t\tconst value = perkStat.value || 0;\n  // \t\t\tif (itemStat) {\n  // \t\t\t\titemStat.investmentValue += value;\n  // \t\t\t} else if (shouldShowStat(itemDef, statHash, statDisplays)) {\n  // \t\t\t\t// This stat didn't exist before we modified it, so add it here.\n  // \t\t\t\tconst stat = socket.plug.plugItem.investmentStats.find(\n  // \t\t\t\t(s) => s.statTypeHash === statHash\n  // \t\t\t\t);\n  // \t\t\t\tif (stat && stat.value) {\n  // \t\t\t\t\tconst statDef = defs.Stat.get(statHash);\n  // \t\t\t\t\tconst builtStat = buildStat(stat, statGroup, statDef, statDisplays);\n  // \t\t\t\t\tstatsByHash[statHash] = builtStat;\n  // \t\t\t\t\tstats.push(statsByHash[statHash]);\n  // \t\t\t\t}\n  // \t\t\t}\n  // \t\t\tconsole.log(statHash)\n  // \t\t\t// modifiedStats.add(statHash);\n  // \t\t}\n  // \t}\n  // }\n  // Now calculate the actual, interpolated value of all stats after they've been modified\n  // for (const stat of stats) {\n  // \tif (modifiedStats.has(stat.statHash)) {\n  // \t\tconst statDisplay = statDisplays[stat.statHash];\n  // \t\tstat.value = statDisplay\n  // \t\t\t? interpolateStatValue(stat.investmentValue, statDisplays[stat.statHash])\n  // \t\t\t: Math.min(stat.investmentValue, stat.maximumValue);\n  // \t}\n  // }\n  // // We sort the sockets by length so that we count contributions from plugs with fewer options first.\n  // // This is because multiple plugs can contribute to the same stat, so we want to sink the non-changeable\n  // // stats in first.\n  // const sortedSockets = _.sortBy(sockets, (s) => s.plugOptions.length);\n  // for (const socket of sortedSockets) {\n  // for (const plug of socket.plugOptions) {\n  // if (plug.plugItem && plug.plugItem.investmentStats && plug.plugItem.investmentStats.length) {\n  // plug.stats = buildPlugStats(plug, statsByHash, statDisplays);\n  // }\n  // }\n  // }\n  // return stats;\n}\nexport function buildEnhancedStat(theManifest, itemDef, statDef) {\n  console.log('----- Building single stat. -----');\n  console.log(statDef.displayProperties.name);\n  manifest = theManifest;\n  const perkInvestmentStats = statDef.investmentStats;\n  const statGroup = manifest.DestinyStatGroupDefinition[itemDef.stats.statGroupHash];\n  const statDisplays = statGroup.scaledStats;\n  let returningStats;\n\n  if (perkInvestmentStats.length === 0) {\n    return null;\n  }\n\n  if (!itemDef.stats || !itemDef.stats.statGroupHash) {\n    return null;\n  }\n\n  if (!statGroup) {\n    return null;\n  }\n\n  let investmentStats = buildInvestmentStats(itemDef, statGroup);\n  returningStats = perkInvestmentStats.map(perkStat => {\n    let value = perkStat.value || 0;\n    const itemStat = investmentStats.filter(s => {\n      if (s !== undefined) {\n        if (perkStat.statTypeHash === s.statHash) {\n          return s;\n        }\n      }\n\n      return null;\n    })[0];\n    const statDisplay = statDisplays.filter(s => perkStat.statTypeHash === s.statHash)[0];\n\n    if (itemStat && statDisplay) {\n      // This is a scaled stat, so we need to scale it in context of the original investment stat.\n      // Figure out what the interpolated stat value would be without this perk's contribution, and\n      // then take the difference between the total value and that to find the contribution.\n      const valueWithoutPerk = interpolateStatValue(itemStat.investmentValue - value, statDisplay);\n      value = itemStat.value - valueWithoutPerk;\n    } else if (itemStat) {\n      const valueWithoutPerk = Math.max(itemStat.investmentValue - value, itemStat.maximumValue);\n      value = itemStat.value - valueWithoutPerk;\n    }\n\n    return {\n      displayProperties: itemStat.displayProperties,\n      hash: itemStat.statHash,\n      value\n    };\n  });\n  return returningStats;\n}","map":{"version":3,"sources":["/Users/aundrekerr/Projects/React2019/gunsmith3/src/utils/stats.js"],"names":["manifest","statWhiteList","statsNoBar","statsMs","hiddenStatsWhitelist","buildStats","theManifest","itemHash","console","log","itemDef","DestinyInventoryItemDefinition","stats","statGroupHash","statGroup","DestinyStatGroupDefinition","investmentStats","buildInvestmentStats","sort","a","b","shouldShowStat","statHash","statDisplays","itemCategoryHashes","includes","filter","s","itemStats","scaledStats","map","itemStat","statTypeHash","undefined","def","DestinyStatDefinition","buildStat","statDef","value","maximumValue","bar","smallerIsBetter","statDisplay","intd","firstInterp","displayInterpolation","lastInterp","length","weight","Math","max","displayAsNumeric","interpolateStatValue","investmentValue","displayProperties","indexOf","interp","min","endIndex","findIndex","p","startIndex","start","end","range","t","round","enhanceStatsWithPlugs","baseStats","hash","perks","mod","masterwork","Object","keys","perk","perkDef","baseStat","perkStat","buildEnhancedStat","name","perkInvestmentStats","returningStats","valueWithoutPerk"],"mappings":"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","sourcesContent":["let manifest;\n\nexport const statWhiteList = [\n\t3614673599, // Blast Radius\n\t2523465841, // Velocity\n\n\t4043523819, // Impact\n\t1240592695, // Range\n\t1591432999, // Accuracy\n\t155624089, // Stability\n\t943549884, // Handling\n\t4188031367, // Reload Speed\n\n\t2837207746, // Swing Speed (sword)\n\t2762071195, // Efficiency (sword)\n\t209426660, // Defense (sword)\n\t\n\t1345609583, // Aim Assistance\n\t3555269338, // Zoom\n\t2715839340, // Recoil Direction\n\n\t4284893193, // Rounds Per Minute\n\t2961396640, // Charge Time\n\t447667954, // Draw Time\n\n\t3871231066, // Magazine\n\t1931675084, // Inventory Size\n\t925767036, // Ammo Capacity\n];\n\nconst statsNoBar = [\n\t4284893193, // Rounds Per Minute\n\t3871231066, // Magazine\n\t2961396640, // Charge Time\n\t447667954, // Draw Time\n\t1931675084, // Recovery\n\t2715839340 // Recoil Direction\n];\n\nexport const statsMs = [\n\t447667954, // Draw Time\n\t2961396640 // Charge Time\n];\n\nconst hiddenStatsWhitelist = [\n\t1345609583, // Aim Assistance\n\t3555269338, // Zoom\n\t2715839340 // Recoil Direction\n];\n\n\n\n\n\n\n\n\nexport function buildStats (\n\ttheManifest,\n\titemHash\n) {\n\tconsole.log('----- Building stats. -----');\n\tmanifest = theManifest;\n\n\tconst itemDef = manifest.DestinyInventoryItemDefinition[itemHash];\n\tif (!itemDef.stats || !itemDef.stats.statGroupHash) {\n\t\treturn null;\n\t}\n\n\tconst statGroup = manifest.DestinyStatGroupDefinition[itemDef.stats.statGroupHash];\n\tif (!statGroup) {\n\t\treturn null;\n\t}\n\n\tlet investmentStats = buildInvestmentStats(itemDef, statGroup);\n\treturn investmentStats.sort((a, b) => { return a.sort-b.sort })\n}\n\nfunction shouldShowStat (\n\titemDef, \n\tstatHash, \n\tstatDisplays\n) {\n\t\n\tif (\n\t\tstatHash === 2961396640 &&\n\t\titemDef.itemCategoryHashes &&\n\t\titemDef.itemCategoryHashes.includes(3317538576)\n\t) {\n\t\treturn false;\n\t}\n\t\n\treturn (\n\t\t// Must be on the whitelist\n\t\tstatWhiteList.includes(statHash) &&\n\t\t// Must be on the list of interpolated stats, or included in the hardcoded hidden stats list\n\t\t(statDisplays.filter(s => statHash === s.statHash)[0] || hiddenStatsWhitelist.includes(statHash))\n\t);\n}\n\nfunction buildInvestmentStats (\n\titemDef, \n\tstatGroup\n) {\n\tconst itemStats = itemDef.investmentStats;\n\tconst statDisplays = statGroup.scaledStats;\n\n\treturn itemStats.map(itemStat => {\n\t\tconst statHash = itemStat.statTypeHash;\n\t\tif (!itemStat || !shouldShowStat(itemDef, statHash, statDisplays)) {\n\t\t\treturn undefined\n\t\t}\n\n\t\tconst def = manifest.DestinyStatDefinition[statHash];\n\t\tif (!def) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn buildStat(itemStat, statGroup, def, statDisplays);\n\t})\n}\n\nfunction buildStat (\n\titemStat,\n\tstatGroup,\n\tstatDef,\n\tstatDisplays\n) {\n\tconst statHash = itemStat.statTypeHash;\n\tlet value = itemStat.value || 0;\n\tlet maximumValue = statGroup.maximumValue;\n\tlet bar = !statsNoBar.includes(statHash);\n\tlet smallerIsBetter = false;\n\tconst statDisplay = statDisplays.filter(s => statHash === s.statHash)[0];\n\tlet intd = false;\n\n\tif ( statDisplay ) {\n\t\tconst firstInterp = statDisplay.displayInterpolation[0];\n\t\tconst lastInterp = statDisplay.displayInterpolation[statDisplay.displayInterpolation.length - 1];\n\n\t\tsmallerIsBetter = firstInterp.weight > lastInterp.weight;\n\t\tmaximumValue = Math.max(statDisplay.maximumValue, firstInterp.weight, lastInterp.weight);\n\t\tbar = !statDisplay.displayAsNumeric;\n\t\tvalue = interpolateStatValue(value, statDisplay);\n\t\tintd = true;\n\t}\n\tvalue = Math.max(0, value);\n\n\treturn {\n\t\tinvestmentValue: itemStat.value || 0,\n\t\tvalue,\n\t\tintd,\n\t\tstatHash,\n\t\tdisplayProperties: statDef.displayProperties,\n\t\tsort: statWhiteList.indexOf(statHash),\n\t\tmaximumValue,\n\t\tbar,\n\t\tsmallerIsBetter\n\t}\n}\n\nfunction interpolateStatValue (\n\tvalue,\n\tstatDisplay\n) {\n\tconst interp = statDisplay.displayInterpolation;\n\t\n\tvalue = Math.max(0, Math.min(value, statDisplay.maximumValue));\n\n\tlet endIndex = interp.findIndex(p => p.value > value);\n\tif (endIndex < 0) {\n\t\tendIndex = interp.length - 1;\n\t}\n\tconst startIndex = Math.max(0, endIndex - 1);\n\n\tconst start = interp[startIndex];\n\tconst end = interp[endIndex];\n\tconst range = end.value - start.value;\n\tif (range === 0) {\n\t\treturn start.weight;\n\t}\n\n\tconst t = (value - start.value) / (end.value - start.value);\n\n\treturn Math.round(start.weight + t * (end.weight - start.weight));\n}\n\nexport function enhanceStatsWithPlugs (\n\tbaseStats,\n\thash,\n\tperks,\n\tmod,\n\tmasterwork\n) {\n\t// console.log(baseStats, perks, mod, masterwork);\n\n\tconst itemDef = manifest.DestinyInventoryItemDefinition[hash];\n\tconst statGroup = manifest.DestinyStatGroupDefinition[itemDef.stats.statGroupHash];\n\n\tObject.keys(perks).map(perk => {\n\t\tconst perkDef = manifest.DestinyInventoryItemDefinition[perks[perk].hash];\n\t\tconst statDisplays = statGroup.scaledStats;\n\n\t\tfor (const baseStat of baseStats) {\n\t\t\tif ( baseStat && perkDef ) {\n\t\t\t\tfor ( const perkStat of perkDef.investmentStats ) {\n\t\t\t\t\tconst statHash = perkStat.statTypeHash;\n\t\t\t\t\tconst itemStat = baseStat;\n\t\t\t\t\tconst statDisplay = statDisplays.filter(s => statHash === s.statHash)[0];\n\t\t\t\t\tconst value = perkStat.value || 0;\n\n\t\t\t\t\tif (itemStat) {\n\t\t\t\t\t\titemStat.investmentValue += value;\n\t\t\t\t\t\tconsole.log(itemStat)\n\t\t\t\t\t\tconsole.log(interpolateStatValue(itemStat.investmentValue, statDisplay))\n\t\t\t\t\t} else if (shouldShowStat(itemDef, statHash, statDisplays)) {\n\t\t\t\t\t\t// const stat = perkDef.investmentStats.find( (s) => s.statTypeHash === statHash );\n\t\t\t\t\t\t// console.log(stat);\n\n\t\t\t\t\t\t// if (stat && stat.value) {\n\t\t\t\t\t\t\t// const statDef = defs.Stat.get(statHash);\n\t\t\t\t\t\t\t// const builtStat = buildStat(stat, statGroup, statDef, statDisplays);\n\t\t\t\t\t\t\t// statsByHash[statHash] = builtStat;\n\t\t\t\t\t\t\t// stats.push(statsByHash[statHash]);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\t\n\n\t// const statsByHash = _.keyBy(stats, (s) => s.statHash);\n\n\t// const modifiedStats = new Set<number>();\n\n\t// Add the chosen plugs' investment stats to the item's base investment stats\n\t// for (const socket of sockets) {\n\t// \tif (socket.plug) {\n\t// \t\tfor (const perkStat of socket.plug.plugItem.investmentStats) {\n\t// \t\t\tconst statHash = perkStat.statTypeHash;\n\t// \t\t\tconst itemStat = statsByHash[statHash];\n\t// \t\t\tconst value = perkStat.value || 0;\n\n\t// \t\t\tif (itemStat) {\n\t// \t\t\t\titemStat.investmentValue += value;\n\t// \t\t\t} else if (shouldShowStat(itemDef, statHash, statDisplays)) {\n\t// \t\t\t\t// This stat didn't exist before we modified it, so add it here.\n\t// \t\t\t\tconst stat = socket.plug.plugItem.investmentStats.find(\n\t// \t\t\t\t(s) => s.statTypeHash === statHash\n\t// \t\t\t\t);\n\n\t// \t\t\t\tif (stat && stat.value) {\n\t// \t\t\t\t\tconst statDef = defs.Stat.get(statHash);\n\t// \t\t\t\t\tconst builtStat = buildStat(stat, statGroup, statDef, statDisplays);\n\t// \t\t\t\t\tstatsByHash[statHash] = builtStat;\n\t// \t\t\t\t\tstats.push(statsByHash[statHash]);\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t\tconsole.log(statHash)\n\t// \t\t\t// modifiedStats.add(statHash);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// Now calculate the actual, interpolated value of all stats after they've been modified\n\t// for (const stat of stats) {\n\t// \tif (modifiedStats.has(stat.statHash)) {\n\t// \t\tconst statDisplay = statDisplays[stat.statHash];\n\t// \t\tstat.value = statDisplay\n\t// \t\t\t? interpolateStatValue(stat.investmentValue, statDisplays[stat.statHash])\n\t// \t\t\t: Math.min(stat.investmentValue, stat.maximumValue);\n\t// \t}\n\t// }\n\n\t// // We sort the sockets by length so that we count contributions from plugs with fewer options first.\n\t// // This is because multiple plugs can contribute to the same stat, so we want to sink the non-changeable\n\t// // stats in first.\n\t// const sortedSockets = _.sortBy(sockets, (s) => s.plugOptions.length);\n\t// for (const socket of sortedSockets) {\n\t// for (const plug of socket.plugOptions) {\n\t// if (plug.plugItem && plug.plugItem.investmentStats && plug.plugItem.investmentStats.length) {\n\t// plug.stats = buildPlugStats(plug, statsByHash, statDisplays);\n\t// }\n\t// }\n\t// }\n\n\t// return stats;\n}\n\n\n\n\n\n\n\nexport function buildEnhancedStat (\n\ttheManifest,\n\titemDef,\n\tstatDef\n) {\n\tconsole.log('----- Building single stat. -----');\n\tconsole.log(statDef.displayProperties.name)\n\tmanifest = theManifest;\n\tconst perkInvestmentStats = statDef.investmentStats;\n\n\tconst statGroup = manifest.DestinyStatGroupDefinition[itemDef.stats.statGroupHash];\n\tconst statDisplays = statGroup.scaledStats;\n\tlet returningStats;\n\n\tif (perkInvestmentStats.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!itemDef.stats || !itemDef.stats.statGroupHash) {\n\t\treturn null;\n\t}\n\n\tif (!statGroup) {\n\t\treturn null;\n\t}\n\n\tlet investmentStats = buildInvestmentStats(itemDef, statGroup);\n\t\n\treturningStats = perkInvestmentStats.map(perkStat => {\n\t\tlet value = perkStat.value || 0;\n\t\tconst itemStat = investmentStats.filter(s => { if ( s !== undefined ) { if (perkStat.statTypeHash === s.statHash) { return s } } return null; })[0];\n\t\tconst statDisplay = statDisplays.filter(s => perkStat.statTypeHash === s.statHash )[0];\n\n\t\tif (itemStat && statDisplay) {\n\t\t\t// This is a scaled stat, so we need to scale it in context of the original investment stat.\n\t\t\t// Figure out what the interpolated stat value would be without this perk's contribution, and\n\t\t\t// then take the difference between the total value and that to find the contribution.\n\t\t\tconst valueWithoutPerk = interpolateStatValue(itemStat.investmentValue - value, statDisplay);\n\t\t\tvalue = itemStat.value - valueWithoutPerk;\n\t\t} else if (itemStat) {\n\t\t\tconst valueWithoutPerk = Math.max(itemStat.investmentValue - value, itemStat.maximumValue);\n\t\t\tvalue = itemStat.value - valueWithoutPerk;\n\t\t}\n\n\t\treturn {\n\t\t\tdisplayProperties: itemStat.displayProperties,\n\t\t\thash: itemStat.statHash,\n\t\t\tvalue\n\t\t};\n\t});\n\n\treturn returningStats;\n}"]},"metadata":{},"sourceType":"module"}