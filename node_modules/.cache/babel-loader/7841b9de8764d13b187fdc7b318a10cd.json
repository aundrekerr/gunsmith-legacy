{"ast":null,"code":"let manifest;\nexport function buildPerks(theManifest, weapon) {\n  console.log('----- Building perks. -----'); // Set up inital variables.\n\n  manifest = theManifest;\n  const itemDef = manifest.DestinyInventoryItemDefinition[weapon.hash]; // Maximum of 4 perk slots. Not a good idea since if 5-perk weapon \n  // could come later on.\n\n  let perkList;\n  perkList = collectPerks(itemDef);\n  return perkList;\n  ;\n}\n\nfunction collectPerks(itemDef) {\n  const socketEntries = itemDef.sockets.socketEntries;\n  let perkList = [[], [], [], [], []];\n  let slotCheck = 0;\n  let duplicatePerks = [];\n  perkList.map(column => {\n    let seen = new Set();\n    return column.some(currentPerk => {\n      if (seen.size === seen.add(currentPerk.hash).size) {\n        duplicatePerks.push(currentPerk);\n        return true;\n      }\n\n      return false;\n    });\n  }); // Map through slots to find ones that are genuine perks.\n\n  socketEntries.map(socket => {\n    // Check plug sources to filter out MWs, mods, shaders, etc.\n    if (socket.plugSources === 2) {\n      // Curated & Year 1 weapons. Loop through perk columns.\n      for (let i = 0; i < socket.reusablePlugItems.length; i++) {\n        const plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n        const plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes; // Filter out Kill Trackers.\n\n        if (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n          if (socket.reusablePlugItems.length > 0 && socket.randomizedPlugItems.length > 0) {\n            perkList[slotCheck].push({\n              hash: socket.reusablePlugItems[i].plugItemHash,\n              isCurated: true,\n              curatedOnly: false\n            });\n          } else {\n            perkList[slotCheck].push({\n              hash: socket.reusablePlugItems[i].plugItemHash,\n              isCurated: false,\n              curatedOnly: false\n            });\n          }\n        }\n      } // Year 2+. Loop through perk columns.\n\n\n      for (let i = 0; i < socket.randomizedPlugItems.length; i++) {\n        const plugItemHash = socket.randomizedPlugItems[i].plugItemHash;\n        const plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes; // Filter out Kill Trackers.\n\n        if (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n          console.log(socket.reusablePlugItems.some(p => p.hash === socket.randomizedPlugItems[i].plugItemHash));\n\n          if (socket.reusablePlugItems.some(p => p.hash === socket.randomizedPlugItems[i].plugItemHash)) {\n            console.log('dupe!');\n          }\n\n          perkList[slotCheck].push({\n            hash: socket.randomizedPlugItems[i].plugItemHash,\n            isCurated: false,\n            curatedOnly: false\n          });\n        }\n      } // Increment to move to next perk slot.\n\n\n      slotCheck++;\n    } // ???\n\n\n    return true;\n  });\n  console.log(duplicatePerks, perkList);\n  return perkList;\n} // function isCurated(\n// \titemDef,\n// ) {\n// \tconst socketEntries = itemDef.sockets.socketEntries;\n// \tlet curatedCounter = []\n// \tif (itemDef.inventory.tierTypeHash === 2759499571) return false;\n// \tsocketEntries.map(socket => {\n// \t\t// Check plug sources to filter out MWs, mods, shaders, etc.\n// \t\tif (socket.plugSources === 2) {\n// \t\t\t// If the reusable and randomized sockets are over 1, add it.\n// \t\t\tif (socket.reusablePlugItems.length > 0 && socket.randomizedPlugItems.length > 0) {\n// \t\t\t\tcuratedCounter.push(true);\n// \t\t\t}\n// \t\t}\n// \t})\n// \t// If all true, the weapon has a curated version...?\n// \treturn curatedCounter.every(p => p === true);\n// }","map":{"version":3,"sources":["/Users/aundrekerr/Projects/React2019/gunsmith3/src/utils/perks.js"],"names":["manifest","buildPerks","theManifest","weapon","console","log","itemDef","DestinyInventoryItemDefinition","hash","perkList","collectPerks","socketEntries","sockets","slotCheck","duplicatePerks","map","column","seen","Set","some","currentPerk","size","add","push","socket","plugSources","i","reusablePlugItems","length","plugItemHash","plugItemsCategories","itemCategoryHashes","includes","randomizedPlugItems","isCurated","curatedOnly","p"],"mappings":"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","sourcesContent":["let manifest;\n\nexport function buildPerks(\n\ttheManifest,\n\tweapon\n) {\n\tconsole.log('----- Building perks. -----');\n\n\t// Set up inital variables.\n\tmanifest = theManifest;\n\tconst itemDef = manifest.DestinyInventoryItemDefinition[weapon.hash];\n\n\t// Maximum of 4 perk slots. Not a good idea since if 5-perk weapon \n\t// could come later on.\n\tlet perkList;\n\t\n\tperkList = collectPerks(itemDef)\n\n\treturn perkList;;\n}\n\nfunction collectPerks(\n\titemDef\n) {\n\tconst socketEntries = itemDef.sockets.socketEntries;\n\tlet perkList = [ [], [], [], [], [] ];\n\tlet slotCheck = 0;\n\n\tlet duplicatePerks = [];\n\n\tperkList.map(column => {\n\t\tlet seen = new Set();\n\t\treturn column.some(currentPerk => {\t\n\t\t\tif (seen.size === seen.add(currentPerk.hash).size){\n\t\t\t\tduplicatePerks.push(currentPerk);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t});\n\n\t// Map through slots to find ones that are genuine perks.\n\tsocketEntries.map(socket => {\n\n\t\t// Check plug sources to filter out MWs, mods, shaders, etc.\n\t\tif (socket.plugSources === 2) {\n\n\t\t\t// Curated & Year 1 weapons. Loop through perk columns.\n\t\t\tfor (let i = 0; i < socket.reusablePlugItems.length; i++) {\n\t\t\t\tconst plugItemHash = socket.reusablePlugItems[i].plugItemHash;\n\t\t\t\tconst plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes;\n\n\t\t\t\t// Filter out Kill Trackers.\n\t\t\t\tif (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n\t\t\t\t\tif (socket.reusablePlugItems.length > 0 && socket.randomizedPlugItems.length > 0) {\n\t\t\t\t\t\tperkList[slotCheck].push({\n\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n\t\t\t\t\t\t\tisCurated: true,\n\t\t\t\t\t\t\tcuratedOnly: false\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tperkList[slotCheck].push({\n\t\t\t\t\t\t\thash: socket.reusablePlugItems[i].plugItemHash,\n\t\t\t\t\t\t\tisCurated: false,\n\t\t\t\t\t\t\tcuratedOnly: false\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Year 2+. Loop through perk columns.\n\t\t\tfor (let i = 0; i < socket.randomizedPlugItems.length; i++) {\n\t\t\t\tconst plugItemHash = socket.randomizedPlugItems[i].plugItemHash;\n\t\t\t\tconst plugItemsCategories = manifest.DestinyInventoryItemDefinition[plugItemHash].itemCategoryHashes;\n\n\t\t\t\t// Filter out Kill Trackers.\n\t\t\t\tif (plugItemsCategories.includes(59) && plugItemsCategories.length > 1) {\n\t\t\t\t\t\n\t\t\t\t\tconsole.log((socket.reusablePlugItems).some(p => p.hash === socket.randomizedPlugItems[i].plugItemHash))\n\t\t\t\t\tif ((socket.reusablePlugItems).some(p => p.hash === socket.randomizedPlugItems[i].plugItemHash)) {\n\t\t\t\t\t\tconsole.log('dupe!')\n\t\t\t\t\t}\n\t\t\t\t\t\n\n\t\t\t\t\tperkList[slotCheck].push({\n\t\t\t\t\t\thash: socket.randomizedPlugItems[i].plugItemHash,\n\t\t\t\t\t\tisCurated: false,\n\t\t\t\t\t\tcuratedOnly: false\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Increment to move to next perk slot.\n\t\t\tslotCheck++;\n\t\t}\n\n\t\t// ???\n\t\treturn true;\n\t});\n\n\t\n\n\tconsole.log(duplicatePerks, perkList)\n\n\treturn perkList;\n}\n\n// function isCurated(\n// \titemDef,\n// ) {\n// \tconst socketEntries = itemDef.sockets.socketEntries;\n// \tlet curatedCounter = []\n\n// \tif (itemDef.inventory.tierTypeHash === 2759499571) return false;\n\n// \tsocketEntries.map(socket => {\n\n// \t\t// Check plug sources to filter out MWs, mods, shaders, etc.\n// \t\tif (socket.plugSources === 2) {\n\n// \t\t\t// If the reusable and randomized sockets are over 1, add it.\n// \t\t\tif (socket.reusablePlugItems.length > 0 && socket.randomizedPlugItems.length > 0) {\n// \t\t\t\tcuratedCounter.push(true);\n// \t\t\t}\n// \t\t}\n// \t})\n\n// \t// If all true, the weapon has a curated version...?\n// \treturn curatedCounter.every(p => p === true);\n// }\n"]},"metadata":{},"sourceType":"module"}